import{createClient as e}from"@supabase/supabase-js";let t=null,a=a=>t=e(a.url,a.anonKey),r=()=>{if(!t)throw Error("Supabase client is not initialized");return t},n=async(e,t={})=>{let{page:a=1,limit:n=10,orderBy:i,filters:o}=t,s=r().from(e).select("*");if(o&&o.forEach(({column:e,operator:t,value:a})=>{s=s.filter(e,t,a)}),i&&(s=s.order(i.column,{ascending:i.ascending??!0})),a&&n){let e=(a-1)*n;s=s.range(e,e+n-1)}let{data:l,error:c}=await s;if(c)throw c;return l},i=async(e,t)=>{let{data:a,error:n}=await r().from(e).select("*").eq("id",t).single();if(n)throw n;return a},o=async(e,t)=>{let{data:a,error:n}=await r().from(e).insert(t).select();if(n)throw n;return a},s=async(e,t,a)=>{let{data:n,error:i}=await r().from(e).update(a).eq("id",t).select();if(i)throw i;return n},l=async(e,t)=>{let{error:a}=await r().from(e).delete().eq("id",t);if(a)throw a;return!0},c=async(e,t,a)=>{let{data:n,error:i}=await r().from(e).upsert(t,{onConflict:a.join(",")}).select();if(i)throw i;return n},u=async(e,t)=>{let{data:a,error:n}=await r().auth.signUp({email:e,password:t});if(n)throw n;return a},f=async(e,t)=>{let{data:a,error:n}=await r().auth.signInWithPassword({email:e,password:t});if(n)throw n;return a},d=async()=>{let{error:e}=await r().auth.signOut();if(e)throw e;return!0},w=async()=>{let{data:{user:e},error:t}=await r().auth.getUser();if(t)throw t;return e},h=async(e,t,a,n={})=>{let{data:i,error:o}=await r().storage.from(e).upload(t,a,{upsert:n.upsert??!1,cacheControl:n.cacheControl??"3600"});if(o)throw o;return i},p=async(e,t)=>{let{data:a,error:n}=await r().storage.from(e).download(t);if(n)throw n;return a},g=async(e,t)=>{let{error:a}=await r().storage.from(e).remove([t]);if(a)throw a;return!0},m=async(e,t="")=>{let{data:a,error:n}=await r().storage.from(e).list(t);if(n)throw n;return a},y=async(e,t,a)=>{let r=new Blob([JSON.stringify(a)],{type:"application/json"});return await h(e,t,r,{upsert:!0})},E=async(e,t)=>{let a=await p(e,t);return JSON.parse(await a.text())},b=(e,t)=>r().channel(`${e}-changes`).on("postgres_changes",{event:"*",schema:"public",table:e},e=>t(e)).subscribe(),$=async(e={})=>await n("github_accounts",e),T=async e=>{let{data:t,error:a}=await r().from("github_accounts").select("*").eq("username",e).single();if(a)throw a;return t},O=async e=>{let{data:t,error:a}=await r().from("github_accounts").insert({...e,created_at:new Date().toISOString(),updated_at:new Date().toISOString()}).select().single();if(a)throw a;return t},N=async(e,t)=>{let{data:a,error:n}=await r().from("github_accounts").update({...t,updated_at:new Date().toISOString()}).eq("username",e).select().single();if(n)throw n;return a},C=async e=>{let{error:t}=await r().from("github_accounts").delete().eq("username",e);if(t)throw t;return!0},S=async e=>{let t=new Date().toISOString(),{data:a,error:n}=await r().from("github_accounts").upsert(e.map(e=>({...e,updated_at:t,created_at:t})),{onConflict:"username",ignoreDuplicates:!1}).select();if(n)throw n;return a},A=async(e,t)=>{let a=r(),n=`CREATE TABLE ${e.name} (
`;n+=e.columns.map(e=>{let t=`  "${e.name}" ${e.type}`;return e.primaryKey&&(t+=" PRIMARY KEY"),e.unique&&(t+=" UNIQUE"),e.nullable||(t+=" NOT NULL"),void 0!==e.defaultValue&&(t+=` DEFAULT ${e.defaultValue}`),e.check&&(t+=` CHECK (${e.check})`),e.foreignKey&&(t+=` REFERENCES ${e.foreignKey.table}(${e.foreignKey.column})`,e.foreignKey.onDelete&&(t+=` ON DELETE ${e.foreignKey.onDelete}`),e.foreignKey.onUpdate&&(t+=` ON UPDATE ${e.foreignKey.onUpdate}`)),t}).join(",\n"),n+="\n)";let{error:i}=await a.rpc("exec",{query:n});if(i)throw i;if(e.indexes)for(let t of e.indexes){let r=`CREATE${t.unique?" UNIQUE":""} INDEX "${t.name}" ON ${e.name} (${t.columns.map(e=>`"${e}"`).join(", ")})`,{error:n}=await a.rpc("exec",{query:r});if(n)throw n}if(t){let r=[];if(t.select?.enabled){let a=t.select;a.roles.forEach(t=>{let n=`GRANT SELECT ON ${e.name} TO "${t}"`;a.condition&&(n+=` WITH CHECK (${a.condition})`),r.push(n)})}if(t.insert?.enabled){let a=t.insert;a.roles.forEach(t=>{let n=`GRANT INSERT ON ${e.name} TO "${t}"`;a.condition&&(n+=` WITH CHECK (${a.condition})`),r.push(n)})}if(t.update?.enabled){let a=t.update;a.roles.forEach(t=>{let n=`GRANT UPDATE ON ${e.name} TO "${t}"`;a.condition&&(n+=` WITH CHECK (${a.condition})`),r.push(n)})}if(t.delete?.enabled){let a=t.delete;a.roles.forEach(t=>{let n=`GRANT DELETE ON ${e.name} TO "${t}"`;a.condition&&(n+=` WITH CHECK (${a.condition})`),r.push(n)})}for(let e of r){let{error:t}=await a.rpc("exec",{query:e});if(t)throw t}}return!0};export{a as initSupabase,r as getSupabase,n as select,i as selectOne,o as insert,s as update,l as remove,c as upsert,u as signUp,f as signIn,d as signOut,w as getCurrentUser,h as uploadFile,p as downloadFile,g as deleteFile,m as listFiles,y as saveJsonToStorage,E as loadJsonFromStorage,b as subscribe,$ as getGitHubAccounts,T as getGitHubAccount,O as createGitHubAccount,N as updateGitHubAccount,C as deleteGitHubAccount,S as upsertGitHubAccounts,A as createTable};