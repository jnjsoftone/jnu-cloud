import{createClient as e}from"@supabase/supabase-js";let t=null,a=a=>t=e(a.url,a.anonKey),n=()=>{if(!t)throw Error("Supabase client is not initialized");return t},r=async(e,t={})=>{let{page:a=1,limit:r=10,orderBy:i,filters:o}=t,s=n().from(e).select("*");if(o&&o.forEach(({column:e,operator:t,value:a})=>{s=s.filter(e,t,a)}),i&&(s=s.order(i.column,{ascending:i.ascending??!0})),a&&r){let e=(a-1)*r;s=s.range(e,e+r-1)}let{data:u,error:l}=await s;if(l)throw l;return u},i=async(e,t)=>{let{data:a,error:r}=await n().from(e).select("*").eq("id",t).single();if(r)throw r;return a},o=async(e,t)=>{let{data:a,error:r}=await n().from(e).insert(t).select();if(r)throw r;return a},s=async(e,t,a)=>{let{data:r,error:i}=await n().from(e).update(a).eq("id",t).select();if(i)throw i;return r},u=async(e,t)=>{let{error:a}=await n().from(e).delete().eq("id",t);if(a)throw a;return!0},l=async(e,t,a)=>{let{data:r,error:i}=await n().from(e).upsert(t,{onConflict:a.join(",")}).select();if(i)throw i;return r},c=async(e,t)=>{let{data:a,error:r}=await n().auth.signUp({email:e,password:t});if(r)throw r;return a},f=async(e,t)=>{let{data:a,error:r}=await n().auth.signInWithPassword({email:e,password:t});if(r)throw r;return a},w=async()=>{let{error:e}=await n().auth.signOut();if(e)throw e;return!0},d=async()=>{let{data:{user:e},error:t}=await n().auth.getUser();if(t)throw t;return e},g=async(e,t,a,r={})=>{let{data:i,error:o}=await n().storage.from(e).upload(t,a,{upsert:r.upsert??!1,cacheControl:r.cacheControl??"3600"});if(o)throw o;return i},h=async(e,t)=>{let{data:a,error:r}=await n().storage.from(e).download(t);if(r)throw r;return a},p=async(e,t)=>{let{error:a}=await n().storage.from(e).remove([t]);if(a)throw a;return!0},m=async(e,t="")=>{let{data:a,error:r}=await n().storage.from(e).list(t);if(r)throw r;return a},y=async(e,t,a)=>{let n=new Blob([JSON.stringify(a)],{type:"application/json"});return await g(e,t,n,{upsert:!0})},b=async(e,t)=>{let a=await h(e,t);return JSON.parse(await a.text())},E=(e,t)=>n().channel(`${e}-changes`).on("postgres_changes",{event:"*",schema:"public",table:e},e=>t(e)).subscribe(),S=async(e={})=>await r("github_accounts",e),$=async e=>{let{data:t,error:a}=await n().from("github_accounts").select("*").eq("username",e).single();if(a)throw a;return t},O=async e=>{let{data:t,error:a}=await n().from("github_accounts").insert({...e,created_at:new Date().toISOString(),updated_at:new Date().toISOString()}).select().single();if(a)throw a;return t},T=async(e,t)=>{let{data:a,error:r}=await n().from("github_accounts").update({...t,updated_at:new Date().toISOString()}).eq("username",e).select().single();if(r)throw r;return a},I=async e=>{let{error:t}=await n().from("github_accounts").delete().eq("username",e);if(t)throw t;return!0},N=async e=>{let t=new Date().toISOString(),{data:a,error:r}=await n().from("github_accounts").upsert(e.map(e=>({...e,updated_at:t,created_at:t})),{onConflict:"username",ignoreDuplicates:!1}).select();if(r)throw r;return a},C=(e,t)=>{let a=[],n=`CREATE TABLE IF NOT EXISTS ${e.name} (
`;if(n+=e.columns.map(e=>{let t=`  "${e.name}" ${e.type}`;return e.primaryKey&&(t+=" PRIMARY KEY"),e.unique&&(t+=" UNIQUE"),e.nullable||(t+=" NOT NULL"),void 0!==e.defaultValue&&(t+=` DEFAULT ${e.defaultValue}`),e.check&&(t+=` CHECK (${e.check})`),e.foreignKey&&(t+=` REFERENCES ${e.foreignKey.table}(${e.foreignKey.column})`,e.foreignKey.onDelete&&(t+=` ON DELETE ${e.foreignKey.onDelete}`),e.foreignKey.onUpdate&&(t+=` ON UPDATE ${e.foreignKey.onUpdate}`)),t}).join(",\n"),n+="\n);",a.push(n),e.indexes)for(let t of e.indexes){let n=`CREATE${t.unique?" UNIQUE":""} INDEX IF NOT EXISTS "${t.name}" ON ${e.name} (${t.columns.map(e=>`"${e}"`).join(", ")});`;a.push(n)}return t&&["select","insert","update","delete"].forEach(n=>{let r=t[n];r?.enabled&&r.roles.forEach(t=>{let i=`GRANT ${n.toUpperCase()} ON ${e.name} TO "${t}"`;r.condition&&(i+=` WITH CHECK (${r.condition})`),i+=";",a.push(i)})}),a};export{a as initSupabase,n as getSupabase,r as select,i as selectOne,o as insert,s as update,u as remove,l as upsert,c as signUp,f as signIn,w as signOut,d as getCurrentUser,g as uploadFile,h as downloadFile,p as deleteFile,m as listFiles,y as saveJsonToStorage,b as loadJsonFromStorage,E as subscribe,S as getGitHubAccounts,$ as getGitHubAccount,O as createGitHubAccount,T as updateGitHubAccount,I as deleteGitHubAccount,N as upsertGitHubAccounts,C as sqlCreateTable};