"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),!function(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}(exports,{createGitHubAccount:function(){return O},createTable:function(){return A},deleteFile:function(){return g},deleteGitHubAccount:function(){return N},downloadFile:function(){return p},getCurrentUser:function(){return w},getGitHubAccount:function(){return T},getGitHubAccounts:function(){return $},getSupabase:function(){return r},initSupabase:function(){return n},insert:function(){return o},listFiles:function(){return m},loadJsonFromStorage:function(){return E},remove:function(){return c},saveJsonToStorage:function(){return y},select:function(){return a},selectOne:function(){return i},signIn:function(){return f},signOut:function(){return d},signUp:function(){return l},subscribe:function(){return b},update:function(){return u},updateGitHubAccount:function(){return C},uploadFile:function(){return h},upsert:function(){return s},upsertGitHubAccounts:function(){return S}});const e=require("@supabase/supabase-js");let t=null;const n=n=>t=(0,e.createClient)(n.url,n.anonKey),r=()=>{if(!t)throw Error("Supabase client is not initialized");return t},a=async(e,t={})=>{let{page:n=1,limit:a=10,orderBy:i,filters:o}=t,u=r().from(e).select("*");if(o&&o.forEach(({column:e,operator:t,value:n})=>{u=u.filter(e,t,n)}),i&&(u=u.order(i.column,{ascending:i.ascending??!0})),n&&a){let e=(n-1)*a;u=u.range(e,e+a-1)}let{data:c,error:s}=await u;if(s)throw s;return c},i=async(e,t)=>{let{data:n,error:a}=await r().from(e).select("*").eq("id",t).single();if(a)throw a;return n},o=async(e,t)=>{let{data:n,error:a}=await r().from(e).insert(t).select();if(a)throw a;return n},u=async(e,t,n)=>{let{data:a,error:i}=await r().from(e).update(n).eq("id",t).select();if(i)throw i;return a},c=async(e,t)=>{let{error:n}=await r().from(e).delete().eq("id",t);if(n)throw n;return!0},s=async(e,t,n)=>{let{data:a,error:i}=await r().from(e).upsert(t,{onConflict:n.join(",")}).select();if(i)throw i;return a},l=async(e,t)=>{let{data:n,error:a}=await r().auth.signUp({email:e,password:t});if(a)throw a;return n},f=async(e,t)=>{let{data:n,error:a}=await r().auth.signInWithPassword({email:e,password:t});if(a)throw a;return n},d=async()=>{let{error:e}=await r().auth.signOut();if(e)throw e;return!0},w=async()=>{let{data:{user:e},error:t}=await r().auth.getUser();if(t)throw t;return e},h=async(e,t,n,a={})=>{let{data:i,error:o}=await r().storage.from(e).upload(t,n,{upsert:a.upsert??!1,cacheControl:a.cacheControl??"3600"});if(o)throw o;return i},p=async(e,t)=>{let{data:n,error:a}=await r().storage.from(e).download(t);if(a)throw a;return n},g=async(e,t)=>{let{error:n}=await r().storage.from(e).remove([t]);if(n)throw n;return!0},m=async(e,t="")=>{let{data:n,error:a}=await r().storage.from(e).list(t);if(a)throw a;return n},y=async(e,t,n)=>{let r=new Blob([JSON.stringify(n)],{type:"application/json"});return await h(e,t,r,{upsert:!0})},E=async(e,t)=>{let n=await p(e,t);return JSON.parse(await n.text())},b=(e,t)=>r().channel(`${e}-changes`).on("postgres_changes",{event:"*",schema:"public",table:e},e=>t(e)).subscribe(),$=async(e={})=>await a("github_accounts",e),T=async e=>{let{data:t,error:n}=await r().from("github_accounts").select("*").eq("username",e).single();if(n)throw n;return t},O=async e=>{let{data:t,error:n}=await r().from("github_accounts").insert({...e,created_at:new Date().toISOString(),updated_at:new Date().toISOString()}).select().single();if(n)throw n;return t},C=async(e,t)=>{let{data:n,error:a}=await r().from("github_accounts").update({...t,updated_at:new Date().toISOString()}).eq("username",e).select().single();if(a)throw a;return n},N=async e=>{let{error:t}=await r().from("github_accounts").delete().eq("username",e);if(t)throw t;return!0},S=async e=>{let t=new Date().toISOString(),{data:n,error:a}=await r().from("github_accounts").upsert(e.map(e=>({...e,updated_at:t,created_at:t})),{onConflict:"username",ignoreDuplicates:!1}).select();if(a)throw a;return n},A=async(e,t)=>{let n=r(),a=`CREATE TABLE ${e.name} (
`;a+=e.columns.map(e=>{let t=`  "${e.name}" ${e.type}`;return e.primaryKey&&(t+=" PRIMARY KEY"),e.unique&&(t+=" UNIQUE"),e.nullable||(t+=" NOT NULL"),void 0!==e.defaultValue&&(t+=` DEFAULT ${e.defaultValue}`),e.check&&(t+=` CHECK (${e.check})`),e.foreignKey&&(t+=` REFERENCES ${e.foreignKey.table}(${e.foreignKey.column})`,e.foreignKey.onDelete&&(t+=` ON DELETE ${e.foreignKey.onDelete}`),e.foreignKey.onUpdate&&(t+=` ON UPDATE ${e.foreignKey.onUpdate}`)),t}).join(",\n"),a+="\n)";let{error:i}=await n.rpc("exec",{query:a});if(i)throw i;if(e.indexes)for(let t of e.indexes){let r=`CREATE${t.unique?" UNIQUE":""} INDEX "${t.name}" ON ${e.name} (${t.columns.map(e=>`"${e}"`).join(", ")})`,{error:a}=await n.rpc("exec",{query:r});if(a)throw a}if(t){let r=[];if(t.select?.enabled){let n=t.select;n.roles.forEach(t=>{let a=`GRANT SELECT ON ${e.name} TO "${t}"`;n.condition&&(a+=` WITH CHECK (${n.condition})`),r.push(a)})}if(t.insert?.enabled){let n=t.insert;n.roles.forEach(t=>{let a=`GRANT INSERT ON ${e.name} TO "${t}"`;n.condition&&(a+=` WITH CHECK (${n.condition})`),r.push(a)})}if(t.update?.enabled){let n=t.update;n.roles.forEach(t=>{let a=`GRANT UPDATE ON ${e.name} TO "${t}"`;n.condition&&(a+=` WITH CHECK (${n.condition})`),r.push(a)})}if(t.delete?.enabled){let n=t.delete;n.roles.forEach(t=>{let a=`GRANT DELETE ON ${e.name} TO "${t}"`;n.condition&&(a+=` WITH CHECK (${n.condition})`),r.push(a)})}for(let e of r){let{error:t}=await n.rpc("exec",{query:e});if(t)throw t}}return!0};